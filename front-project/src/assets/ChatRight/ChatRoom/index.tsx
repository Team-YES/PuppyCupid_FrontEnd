import { useRouter } from "next/router";
import { ChatRoomWrapper } from "./styled";
import { useState, useEffect, useRef, KeyboardEvent } from "react";
import axios from "axios";
import { useSelector } from "react-redux";
import data from "@emoji-mart/data";
import Picker from "@emoji-mart/react";
import { useClickOutside } from "@/hooks/useClickOutside";
import { RootState } from "@/store/store";
import { useQuery, useQueryClient, useMutation } from "@tanstack/react-query";
import { format } from "date-fns";
import ReportModal from "../../../components/ReportModal";

interface Message {
  id: number;
  content: string;
  created_at: string;
  sender: {
    id: number;
    nickName: string;
  };
  receiver: {
    id: number;
    nickName: string;
  };
  system?: boolean;
}
type ChatRoomProps = {
  setOpenChat: React.Dispatch<React.SetStateAction<boolean>>;
};

// Î©îÏãúÏßÄ Î∂àÎü¨Ïò§Í∏∞ (2Ï¥àÎßàÎã§ Í∞±Ïã†)
const fetchMessages = async (receiverId: number) => {
  const res = await axios.get(`http://localhost:5000/messages/${receiverId}`, {
    withCredentials: true,
  });

  return res.data.messages;
};

// Î©îÏãúÏßÄ Î≥¥ÎÇ¥Í∏∞
const sendMessage = async ({
  receiverId,
  content,
}: {
  receiverId: number;
  content: string;
}) => {
  const res = await axios.post(
    `http://localhost:5000/messages`,
    { receiverId, content },
    { withCredentials: true }
  );
  return res.data;
};

const ChatRoom = ({ setOpenChat }: ChatRoomProps) => {
  const router = useRouter();
  const queryClient = useQueryClient();
  const { receiverId } = router.query;
  const myId = useSelector((state: RootState) => state.user.user?.id);
  const [receiverNickName, setReceiverNickName] = useState("");
  const [input, setInput] = useState("");
  // Ïã†Í≥†ÌïòÍ∏∞
  const [showReportModal, setShowReportModal] = useState(false);

  // Ïú†Ï†Ä Í∞ÄÏ†∏Ïò§Í∏∞(reducers)
  const parsedId = Number(
    Array.isArray(receiverId) ? receiverId[0] : receiverId
  );
  const chatUsers = useSelector((state: RootState) => state.chatUsers.users);
  const receiverUser = chatUsers.find((user) => user.id === parsedId);
  const receiverImage = receiverUser?.dogImage
    ? `http://localhost:5000${receiverUser.dogImage}`
    : "/puppy_profile.png";

  // Ïù¥Î™®Ìã∞ÏΩò
  const [showPicker, setShowPicker] = useState(false);
  const pickerRef = useRef<HTMLDivElement>(null);
  const bottomRef = useRef<HTMLDivElement | null>(null);

  // Ïò§Î•∏Ï™Ω ... Î©îÎâ¥
  const [showOptions, setShowOptions] = useState(false);
  const optionsWrapperRef = useRef<HTMLDivElement>(null);
  useClickOutside(optionsWrapperRef, () => setShowOptions(false));

  // Î©îÏãúÏßÄ Î∂àÎü¨Ïò§Í∏∞ (2Ï¥àÎßàÎã§ polling)
  const { data: messages = [] } = useQuery<Message[]>({
    queryKey: ["messages", parsedId],
    queryFn: () => fetchMessages(parsedId),
    enabled: !!parsedId,
    refetchInterval: 2000,
  });

  // Î©îÏãúÏßÄ Ï†ÑÏÜ° mutation
  const mutation = useMutation({
    mutationFn: sendMessage,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["messages", parsedId] });
    },
  });

  // Î©îÏãúÏßÄ ÏÇ≠Ï†ú axios
  const deleteMessage = async (otherUserId: number) => {
    const res = await axios.delete(
      `http://localhost:5000/messages/${otherUserId}`,
      {
        withCredentials: true,
      }
    );

    return res.data;
  };

  // Ï±ÑÌåÖ ÏÇ≠Ï†ú
  const deleteMessageMutation = useMutation({
    mutationFn: deleteMessage,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["messages", parsedId] });
    },
  });

  const handleDeleteMessage = () => {
    deleteMessageMutation.mutate(parsedId, {
      onSuccess: () => {
        queryClient.invalidateQueries({ queryKey: ["messages", parsedId] });
        setOpenChat(false);
        router.push("/chat");
      },
    });
  };

  // ÏÉÅÎåÄÎ∞© ÎãâÎÑ§ÏûÑ ÏÑ§Ï†ï
  useEffect(() => {
    if (messages.length > 0 && myId) {
      const firstMsg = messages[0];
      const otherUser =
        firstMsg.sender.id === myId ? firstMsg.receiver : firstMsg.sender;
      setReceiverNickName(otherUser.nickName || "");
    }
  }, [messages, myId]);

  // Î©îÏãúÏßÄ Ïä§ÌÅ¨Î°§ ÏïÑÎûòÎ°ú
  useEffect(() => {
    bottomRef.current?.scrollIntoView({ behavior: "smooth" });
  }, [messages]);

  // const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
  //   if (e.key === "Enter" && !e.shiftKey) {
  //     e.preventDefault();
  //     if (input.trim()) {
  //       mutation.mutate({ receiverId: parsedId, content: input });
  //       setInput("");
  //     }
  //   }
  // };
  const handleKeyDown = (e: KeyboardEvent<HTMLInputElement>) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      if (!input.trim()) return;

      const latestMessage = messages[messages.length - 1];

      console.log("latestMessage", latestMessage);
      if (
        latestMessage?.system === true &&
        /Ï±ÑÌåÖ.*ÎÇòÍ∞îÏäµÎãàÎã§/.test(latestMessage.content)
      ) {
        alert("ÏÉÅÎåÄÎ∞©Ïù¥ Ï±ÑÌåÖÎ∞©ÏùÑ ÎÇòÍ∞îÏäµÎãàÎã§. Î©îÏãúÏßÄÎ•º Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§.");
        return;
      }
      mutation.mutate({ receiverId: parsedId, content: input });
      setInput("");
    }
  };

  // Ïù¥Î™®ÏßÄ Ïó¥Í∏∞ Ìï®Ïàò
  const handleEmoji = (emoji: any) => {
    setInput((prevInput) => prevInput + emoji.native);
  };

  // Ïô∏Î∂Ä ÌÅ¥Î¶≠ Ïãú Ïù¥Î™®ÏßÄ Ï∞Ω Îã´Í∏∞
  useClickOutside(pickerRef, () => setShowPicker(false));

  // ÌïòÌä∏ Î≥¥ÎÇ¥Í∏∞
  // const handleHeartClick = () => {
  //   if (parsedId) {
  //     const heartMessage = "üíú";
  //     mutation.mutate({ receiverId: parsedId, content: heartMessage });
  //   }
  // };
  const handleHeartClick = () => {
    if (!parsedId) return;

    const latestMessage = messages[messages.length - 1];
    console.log("latestMessage", latestMessage);
    if (
      latestMessage?.system &&
      latestMessage.content.includes("Ï±ÑÌåÖÎ∞©ÏùÑ ÎÇòÍ∞îÏäµÎãàÎã§")
    ) {
      alert("ÏÉÅÎåÄÎ∞©Ïù¥ Ï±ÑÌåÖÎ∞©ÏùÑ ÎÇòÍ∞îÏäµÎãàÎã§. Î©îÏãúÏßÄÎ•º Î≥¥ÎÇº Ïàò ÏóÜÏäµÎãàÎã§.");
      return;
    }

    const heartMessage = "üíú";
    mutation.mutate({ receiverId: parsedId, content: heartMessage });
  };

  // ÏãúÍ∞Ñ Îì§Ïñ¥ ÏûàÎäîÏßÄ
  const isValidDate = (date: any) => {
    return !isNaN(new Date(date).getTime());
  };

  // Ïò§Î•∏Ï™Ω ÏÉÅÎã® ... ÌÜ†Í∏Ä Î≤ÑÌäº
  const toggleOptions = () => {
    setShowOptions((prev) => !prev);
  };

  return (
    <ChatRoomWrapper>
      <div className="ChatRoom_AllWrap">
        <div className="ChatRoom_otheruser_nametitle">
          <div className="ChatRoom_otheruser_nickname">
            {receiverImage && (
              <img
                src={receiverImage}
                alt="receiverImage"
                onClick={() => {
                  if (receiverUser) {
                    router.push(`/otherpage/${receiverUser.id}`);
                  }
                }}
              />
            )}
            <span>{receiverNickName}</span>
          </div>
          <div
            className="ChatRoom_otheruser_info"
            onClick={toggleOptions}
            ref={optionsWrapperRef}
          >
            <i className="fa-solid fa-ellipsis"></i>
            {/* ... Î≤ÑÌäº */}
            {showOptions && (
              <div className="ChatRoom_options_menu">
                <div
                  className="ChatRoom_option_item"
                  onClick={() => {
                    setShowReportModal(true);
                  }}
                >
                  Ïã†Í≥†ÌïòÍ∏∞
                </div>
                <div
                  className="ChatRoom_option_item"
                  onClick={() => handleDeleteMessage()}
                >
                  Ï±ÑÌåÖÏÇ≠Ï†ú
                </div>
              </div>
            )}
          </div>
        </div>
        <div className="ChatRoom_contents_wrap">
          {messages.map((msg, index) => {
            const isMyMessage = msg.sender.id === myId;
            const isSingleEmoji = /^[\p{Emoji}]{1}$/u.test(msg.content.trim());

            let currentDate = "";
            if (isValidDate(msg.created_at)) {
              currentDate = format(new Date(msg.created_at), "yyyy.MM.dd");
            }

            const prevMessage = messages[index - 1];
            let prevDate = null;
            if (prevMessage && isValidDate(prevMessage.created_at)) {
              prevDate = format(new Date(prevMessage.created_at), "yyyy.MM.dd");
            }

            const showDateSeparator = currentDate && currentDate !== prevDate;

            return (
              <div key={msg.id}>
                {showDateSeparator && (
                  <div className="ChatRoom_date_separator">{currentDate}</div>
                )}
                {typeof msg.system === "boolean" && msg.system ? (
                  <div className="ChatRoom_system_message">{msg.content}</div>
                ) : (
                  <div
                    className={`ChatRoom_message_wrap ${
                      isMyMessage ? "my" : "other"
                    }`}
                  >
                    <div>
                      {!isMyMessage && (
                        <div className="ChatRoom_sender_nickname">
                          {msg.sender.nickName}
                        </div>
                      )}
                      <div
                        className={
                          isSingleEmoji
                            ? "ChatRoom_emoji_emessage"
                            : "ChatRoom_text_emessage"
                        }
                      >
                        {msg.content}
                      </div>
                    </div>
                    <div className="ChatRoom_message_time">
                      {isValidDate(msg.created_at) &&
                        format(new Date(msg.created_at), "a h:mm")}
                    </div>
                  </div>
                )}
              </div>
            );
          })}

          <div ref={bottomRef} />
        </div>

        <div className="ChatRoom_Chat_input">
          <i
            className="fa-regular fa-face-smile-wink left-icon"
            onClick={() => setShowPicker(!showPicker)}
          ></i>
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            onKeyDown={handleKeyDown}
            placeholder="Î©îÏãúÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî"
          />
          <i
            className="fa-regular fa-heart right-icon"
            onClick={handleHeartClick}
          ></i>
        </div>
        {/* Ïù¥Î™®Ìã∞ÏΩò ÏÑ†ÌÉùÍ∏∞ ÌëúÏãú */}
        {showPicker && (
          <div
            className="Comments_PickerBox"
            ref={pickerRef}
            style={{
              position: "absolute",
              bottom: "60px", // ÌôîÎ©¥ ÏÉÅÎã®ÏúºÎ°ú Ï°∞Ï†ï (ÌïÑÏöîÏãú Î≥ÄÍ≤Ω)
              zIndex: 9999,
            }}
          >
            <Picker
              data={data}
              onEmojiSelect={handleEmoji}
              onClick={handleHeartClick}
            />
          </div>
        )}
      </div>
      {/* Ïã†Í≥†ÌïòÍ∏∞ */}
      {showReportModal && receiverUser && (
        <ReportModal
          type="user"
          targetId={receiverUser.id}
          onClose={() => setShowReportModal(false)}
        />
      )}
    </ChatRoomWrapper>
  );
};

export default ChatRoom;
